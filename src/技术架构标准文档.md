# 技术架构标准文档

> **版本**: v1.0.0  
> **状态**: 正式发布  
> **适用范围**: 所有后端服务、前端应用、移动端应用  
> **目标**: 建立极致通用的技术标准，确保系统的一致性、可维护性和可扩展性

---

## 目录

1. [架构设计原则](#1-架构设计原则)
2. [分层架构规范](#2-分层架构规范)
3. [数据层规范](#3-数据层规范)
4. [API设计规范](#4-api设计规范)
5. [认证与授权规范](#5-认证与授权规范)
6. [安全规范](#6-安全规范)
7. [性能规范](#7-性能规范)
8. [监控与日志规范](#8-监控与日志规范)
9. [部署与运维规范](#9-部署与运维规范)
10. [代码质量规范](#10-代码质量规范)
11. [附录](#11-附录)

---

## 1. 架构设计原则

### 1.1 核心原则

#### 1.1.1 SOLID原则

| 原则 | 定义 | 实践要求 |
|------|------|----------|
| **S**ingle Responsibility | 单一职责 | 每个类/模块只负责一个功能领域 |
| **O**pen/Closed | 开闭原则 | 对扩展开放，对修改关闭 |
| **L**iskov Substitution | 里氏替换 | 子类必须能够替换父类 |
| **I**nterface Segregation | 接口隔离 | 客户端不应依赖不需要的接口 |
| **D**ependency Inversion | 依赖倒置 | 依赖抽象而非具体实现 |

#### 1.1.2 架构设计原则

```
┌─────────────────────────────────────────────────────────────┐
│                    架构设计金字塔                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│                    ┌─────────────┐                          │
│                    │   高内聚    │  ← 模块内部紧密关联       │
│                    └──────┬──────┘                          │
│                           │                                 │
│              ┌────────────┴────────────┐                    │
│              │        低耦合          │  ← 模块间依赖最小化   │
│              └────────────┬────────────┘                    │
│                           │                                 │
│        ┌──────────────────┴──────────────────┐              │
│        │            可扩展性                 │  ← 易于扩展   │
│        └──────────────────┬──────────────────┘              │
│                           │                                 │
│  ┌────────────────────────┴────────────────────────┐        │
│  │                  可维护性                      │  ← 易于维护 │
│  └─────────────────────────────────────────────────┘        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 1.1.3 设计决策 checklist

在做出任何架构决策前，必须回答以下问题：

- [ ] **可扩展性**: 系统能否水平扩展以应对流量增长？
- [ ] **可靠性**: 单点故障是否被消除？是否有降级策略？
- [ ] **安全性**: 是否遵循最小权限原则？敏感数据是否加密？
- [ ] **可观测性**: 是否可监控、可追踪、可告警？
- [ ] **可维护性**: 新成员能否在1周内理解并贡献代码？
- [ ] **性能**: 是否满足 SLA 要求（响应时间、吞吐量）？
- [ ] **成本**: 资源使用是否高效？

---

## 2. 分层架构规范

### 2.1 标准分层架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              标准分层架构                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         表示层 (Presentation)                        │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │   │
│  │  │  Controller │  │    DTO      │  │   Mapper    │  │  Validator  │ │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         应用层 (Application)                         │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │   │
│  │  │   Service   │  │    Event    │  │   Query     │  │  Command    │ │   │
│  │  │             │  │   Handler   │  │   Handler   │  │   Handler   │ │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         领域层 (Domain)                              │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │   │
│  │  │   Entity    │  │ Value Object│  │  Aggregate  │  │ Domain Event│ │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘ │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │   │
│  │  │  Repository │  │   Service   │  │ Specification│                  │   │
│  │  │  Interface  │  │             │  │             │                  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                       基础设施层 (Infrastructure)                     │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │   │
│  │  │ Repository  │  │   Cache     │  │   Message   │  │   Logger    │ │   │
│  │  │  Impl       │  │   Impl      │  │   Queue     │  │             │ │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘ │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │   │
│  │  │   HTTP      │  │   Email     │  │   Storage   │                  │   │
│  │  │   Client    │  │   Service   │  │   Service   │                  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 依赖规则

```
严格依赖方向（只能向下依赖）:

表示层 ──────▶ 应用层 ──────▶ 领域层 ──────▶ 基础设施层
    │              │              │
    └──────────────┴──────────────┘
              通过依赖注入反转
```

**禁止以下依赖**：
- ❌ 领域层依赖应用层
- ❌ 基础设施层依赖领域层（应通过接口反转）
- ❌ 层之间循环依赖

### 2.3 模块命名规范

```
src/
├── common/                          # 公共模块
│   ├── auth/                        # 认证模块
│   ├── cache/                       # 缓存抽象
│   ├── config/                      # 配置管理
│   ├── events/                      # 事件总线
│   ├── exceptions/                  # 异常定义
│   ├── filters/                     # 全局过滤器
│   ├── guards/                      # 守卫
│   ├── interceptors/                # 拦截器
│   ├── middleware/                  # 中间件
│   ├── pipes/                       # 管道
│   ├── queue/                       # 消息队列
│   ├── redis/                       # Redis服务
│   └── base.entity.ts               # 基础实体
│
├── modules/                         # 业务模块
│   ├── user/                        # 用户模块
│   │   ├── dto/                     # 数据传输对象
│   │   ├── entities/                # 实体定义
│   │   ├── repositories/            # 仓储实现
│   │   ├── services/                # 服务实现
│   │   ├── controllers/             # 控制器
│   │   ├── events/                  # 事件处理器
│   │   └── user.module.ts           # 模块定义
│   │
│   ├── message/                     # 消息模块
│   ├── friend/                      # 好友模块
│   └── group/                       # 群组模块
│
├── gateways/                        # WebSocket网关
├── providers/                       # 第三方服务提供者
└── main.ts                          # 应用入口
```

### 2.4 文件命名规范

| 类型 | 命名规则 | 示例 |
|------|----------|------|
| 实体 | `[name].entity.ts` | `user.entity.ts` |
| DTO | `[action][name]Dto.ts` | `createUserDto.ts` |
| 服务 | `[name].service.ts` | `user.service.ts` |
| 控制器 | `[name].controller.ts` | `user.controller.ts` |
| 模块 | `[name].module.ts` | `user.module.ts` |
| 仓储接口 | `[name].repository.ts` | `user.repository.ts` |
| 仓储实现 | `[name].repository.impl.ts` | `user.repository.impl.ts` |
| 守卫 | `[name].guard.ts` | `jwt-auth.guard.ts` |
| 拦截器 | `[name].interceptor.ts` | `logging.interceptor.ts` |
| 过滤器 | `[name].filter.ts` | `http-exception.filter.ts` |

---

## 3. 数据层规范

### 3.1 数据库设计原则

#### 3.1.1 命名规范

```sql
-- 表名: 小写，下划线分隔，业务前缀
chat_users              -- 用户表
chat_messages           -- 消息表
chat_group_members      -- 群组成员表

-- 字段名: 小写，下划线分隔
id                      -- 主键
created_at              -- 创建时间
updated_at              -- 更新时间
is_deleted              -- 软删除标记

-- 索引名: idx_表名_字段名
idx_chat_messages_from_user_id
idx_chat_messages_created_at

-- 外键名: fk_表名_引用表名
fk_chat_messages_from_user_id_chat_users
```

#### 3.1.2 字段设计标准

```typescript
// 基础实体 - 所有实体必须继承
export abstract class BaseEntity {
  @PrimaryColumn({ type: 'varchar', length: 36 })
  id: string;                          // UUID 主键

  @CreateDateColumn({ type: 'timestamptz' })
  created_at: Date;                    // 创建时间

  @UpdateDateColumn({ type: 'timestamptz' })
  updated_at: Date;                    // 更新时间

  @Column({ type: 'boolean', default: false })
  is_deleted: boolean;                 // 软删除标记

  @Column({ type: 'timestamptz', nullable: true })
  deleted_at: Date;                    // 删除时间

  @Column({ type: 'varchar', length: 36, nullable: true })
  created_by: string;                  // 创建者

  @Column({ type: 'varchar', length: 36, nullable: true })
  updated_by: string;                  // 更新者

  @VersionColumn({ type: 'int', default: 1 })
  version: number;                     // 乐观锁版本号
}
```

### 3.2 索引设计规范

#### 3.2.1 索引设计原则

```typescript
@Entity('chat_messages')
@Index(['from_user_id', 'to_user_id', 'created_at'])     // 复合索引：查询条件+排序
@Index(['to_user_id', 'created_at'])                     // 覆盖索引：避免回表
@Index(['client_seq'], { unique: true })                 // 唯一索引：业务唯一性
@Index(['status'], { where: 'status = \'pending\'' })     // 部分索引：减少索引大小
export class Message extends BaseEntity {
  // ...
}
```

#### 3.2.2 索引 checklist

- [ ] 主键自动创建聚簇索引
- [ ] 外键字段必须创建索引
- [ ] 频繁查询的 WHERE 字段创建索引
- [ ] ORDER BY 字段创建索引
- [ ] 联合索引遵循最左前缀原则
- [ ] 避免过多索引（写性能下降）
- [ ] 定期分析索引使用情况

### 3.3 实体关系规范

```typescript
// 一对多关系
@Entity()
export class User extends BaseEntity {
  @OneToMany(() => Message, message => message.from_user)
  @JoinColumn({ name: 'id', referencedColumnName: 'from_user_id' })
  sent_messages: Message[];
}

// 多对一关系
@Entity()
export class Message extends BaseEntity {
  @Column({ type: 'varchar', length: 36 })
  from_user_id: string;

  @ManyToOne(() => User, user => user.sent_messages)
  @JoinColumn({ name: 'from_user_id' })
  from_user: User;
}

// 多对多关系
@Entity()
export class GroupMember extends BaseEntity {
  @ManyToOne(() => User, user => user.group_memberships, {
    onDelete: 'CASCADE',
  })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @ManyToOne(() => Group, group => group.members, {
    onDelete: 'CASCADE',
  })
  @JoinColumn({ name: 'group_id' })
  group: Group;
}
```

### 3.4 事务管理规范

#### 3.4.1 事务使用原则

```typescript
// ✅ 正确：多表操作使用事务
async transferFunds(fromId: string, toId: string, amount: number): Promise<void> {
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    // 扣减转出方余额
    await queryRunner.manager.decrement(
      Account,
      { id: fromId },
      'balance',
      amount
    );

    // 增加转入方余额
    await queryRunner.manager.increment(
      Account,
      { id: toId },
      'balance',
      amount
    );

    // 记录交易日志
    await queryRunner.manager.save(Transaction, {
      from_id: fromId,
      to_id: toId,
      amount,
      type: 'transfer',
    });

    await queryRunner.commitTransaction();
  } catch (error) {
    await queryRunner.rollbackTransaction();
    throw error;
  } finally {
    await queryRunner.release();
  }
}

// ❌ 错误：多表操作无事务
async badExample(fromId: string, toId: string, amount: number): Promise<void> {
  await this.accountRepository.decrement({ id: fromId }, 'balance', amount);
  // 如果这里失败，数据不一致！
  await this.accountRepository.increment({ id: toId }, 'balance', amount);
  await this.transactionRepository.save({ from_id: fromId, to_id: toId, amount });
}
```

#### 3.4.2 事务传播行为

```typescript
@Injectable()
export class OrderService {
  // REQUIRED: 默认行为，加入已有事务或创建新事务
  @Transactional()
  async createOrder(data: CreateOrderDto): Promise<Order> {
    // ...
  }

  // REQUIRES_NEW: 总是创建新事务
  @Transactional({ propagation: Propagation.REQUIRES_NEW })
  async logOrderCreation(orderId: string): Promise<void> {
    // ...
  }

  // NESTED: 嵌套事务，可独立回滚
  @Transactional({ propagation: Propagation.NESTED })
  async processPayment(orderId: string): Promise<void> {
    // ...
  }
}
```

### 3.5 查询优化规范

#### 3.5.1 分页规范

```typescript
// ✅ 正确：游标分页（推荐用于大数据量）
async getMessagesWithCursor(
  userId: string,
  cursor?: string,
  limit: number = 20
): Promise<CursorPaginatedResult<Message>> {
  const query = this.messageRepository
    .createQueryBuilder('message')
    .where('message.to_user_id = :userId', { userId })
    .orderBy('message.created_at', 'DESC')
    .take(limit + 1);  // 多取一条判断是否还有下一页

  if (cursor) {
    const cursorDate = new Date(Buffer.from(cursor, 'base64').toString());
    query.andWhere('message.created_at < :cursorDate', { cursorDate });
  }

  const messages = await query.getMany();
  const hasMore = messages.length > limit;
  const items = hasMore ? messages.slice(0, -1) : messages;

  const nextCursor = hasMore
    ? Buffer.from(items[items.length - 1].created_at.toISOString()).toString('base64')
    : undefined;

  return { items, nextCursor, hasMore };
}

// ⚠️ 传统分页（仅用于小数据量）
async getMessagesWithOffset(
  userId: string,
  page: number = 1,
  limit: number = 20
): Promise<PaginatedResult<Message>> {
  const [items, total] = await this.messageRepository.findAndCount({
    where: { to_user_id: userId },
    order: { created_at: 'DESC' },
    skip: (page - 1) * limit,
    take: limit,
  });

  return {
    items,
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit),
  };
}
```

#### 3.5.2 N+1 问题解决

```typescript
// ❌ 错误：N+1 查询
const users = await this.userRepository.find();
for (const user of users) {
  const orders = await this.orderRepository.find({ where: { user_id: user.id } });
  // 每用户一次查询！
}

// ✅ 正确：使用 relations 或 QueryBuilder
const users = await this.userRepository.find({
  relations: ['orders'],
});

// ✅ 正确：使用 QueryBuilder 的 leftJoinAndSelect
const users = await this.userRepository
  .createQueryBuilder('user')
  .leftJoinAndSelect('user.orders', 'order')
  .getMany();

// ✅ 正确：使用 DataLoader 批量加载
@Loader(() => OrderLoader)
async getUserOrders(
  @LoaderData() loader: DataLoader<string, Order[]>
): Promise<Order[]> {
  return loader.load(this.userId);
}
```

---

## 4. API 设计规范

### 4.1 RESTful API 规范

#### 4.1.1 URL 设计

```
# 资源命名规范
GET    /api/v1/users              # 获取用户列表
GET    /api/v1/users/:id          # 获取单个用户
POST   /api/v1/users              # 创建用户
PUT    /api/v1/users/:id          # 全量更新用户
PATCH  /api/v1/users/:id          # 部分更新用户
DELETE /api/v1/users/:id          # 删除用户

# 嵌套资源
GET    /api/v1/users/:id/orders           # 获取用户的订单
POST   /api/v1/users/:id/orders           # 为用户创建订单
GET    /api/v1/users/:id/orders/:orderId  # 获取用户的特定订单

# 动作资源（非 CRUD 操作）
POST   /api/v1/users/:id/activate         # 激活用户
POST   /api/v1/users/:id/deactivate       # 停用用户
POST   /api/v1/users/:id/reset-password   # 重置密码
```

#### 4.1.2 HTTP 状态码

| 状态码 | 使用场景 | 示例 |
|--------|----------|------|
| 200 OK | 成功响应 | GET 请求成功 |
| 201 Created | 资源创建成功 | POST 创建用户成功 |
| 204 No Content | 成功但无返回体 | DELETE 删除成功 |
| 400 Bad Request | 请求参数错误 | 缺少必填字段 |
| 401 Unauthorized | 未认证 | Token 缺失或无效 |
| 403 Forbidden | 无权限 | 越权访问 |
| 404 Not Found | 资源不存在 | 用户 ID 不存在 |
| 409 Conflict | 资源冲突 | 重复创建 |
| 422 Unprocessable | 业务逻辑错误 | 余额不足 |
| 429 Too Many Requests | 限流 | 请求过于频繁 |
| 500 Internal Error | 服务器错误 | 未捕获异常 |

### 4.2 请求/响应规范

#### 4.2.1 标准响应格式

```typescript
// 成功响应
{
  "success": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "张三",
    "email": "zhangsan@example.com",
    "created_at": "2024-01-15T08:30:00Z"
  },
  "meta": {
    "request_id": "req_123456789",
    "timestamp": "2024-01-15T08:30:00.123Z"
  }
}

// 列表响应
{
  "success": true,
  "data": {
    "items": [
      { "id": "1", "name": "用户1" },
      { "id": "2", "name": "用户2" }
    ],
    "pagination": {
      "total": 100,
      "page": 1,
      "limit": 20,
      "total_pages": 5,
      "has_next": true,
      "has_prev": false
    }
  },
  "meta": {
    "request_id": "req_123456789",
    "timestamp": "2024-01-15T08:30:00.123Z"
  }
}

// 错误响应
{
  "success": false,
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "用户不存在",
    "details": {
      "user_id": "550e8400-e29b-41d4-a716-446655440000"
    }
  },
  "meta": {
    "request_id": "req_123456789",
    "timestamp": "2024-01-15T08:30:00.123Z"
  }
}
```

#### 4.2.2 DTO 设计规范

```typescript
// create-user.dto.ts
export class CreateUserDto {
  @IsString()
  @Length(2, 50)
  @Matches(/^[\u4e00-\u9fa5a-zA-Z0-9_]+$/, {
    message: '用户名只能包含中文、字母、数字和下划线',
  })
  name: string;

  @IsEmail()
  email: string;

  @IsString()
  @Length(8, 100)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]+$/, {
    message: '密码必须包含大小写字母、数字和特殊字符',
  })
  password: string;

  @IsOptional()
  @IsString()
  @Length(0, 500)
  bio?: string;

  @IsOptional()
  @IsUrl()
  avatar_url?: string;
}

// update-user.dto.ts
export class UpdateUserDto extends PartialType(CreateUserDto) {
  @IsOptional()
  @IsString()
  @Length(2, 50)
  name?: string;
}

// user-response.dto.ts
export class UserResponseDto {
  @Expose()
  id: string;

  @Expose()
  name: string;

  @Expose()
  email: string;

  @Expose()
  avatar_url: string;

  @Expose()
  @Transform(({ value }) => value?.toISOString())
  created_at: Date;

  @Exclude()
  password: string;  // 确保密码不被序列化
}
```

### 4.3 版本控制规范

```
/api/v1/users          # 版本 1（当前稳定版）
/api/v2/users          # 版本 2（新功能，可能不兼容）
```

**版本策略**：
- 主版本号（v1, v2）：不兼容的 API 变更
- 次版本号：向后兼容的功能添加
- 补丁版本号：向后兼容的问题修复

---

## 5. 认证与授权规范

### 5.1 认证体系架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        认证体系架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌──────────┐    ┌──────────┐    ┌──────────┐                 │
│   │  用户名   │    │  手机号   │    │  第三方   │                 │
│   │  密码    │    │  验证码   │    │  OAuth   │                 │
│   └────┬─────┘    └────┬─────┘    └────┬─────┘                 │
│        │               │               │                        │
│        └───────────────┼───────────────┘                        │
│                        ▼                                        │
│              ┌─────────────────┐                                │
│              │   AuthService   │                                │
│              │   验证凭据       │                                │
│              └────────┬────────┘                                │
│                       ▼                                         │
│              ┌─────────────────┐                                │
│              │  JWT Service    │                                │
│              │  生成 Token     │                                │
│              │                 │                                │
│              │  Access Token   │─── 有效期: 15分钟              │
│              │  Refresh Token  │─── 有效期: 7天                 │
│              └────────┬────────┘                                │
│                       ▼                                         │
│              ┌─────────────────┐                                │
│              │   Token Store   │                                │
│              │   (Redis)       │                                │
│              └─────────────────┘                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 JWT 规范

#### 5.2.1 Token 结构

```typescript
// JWT Payload 结构
interface JWTPayload {
  sub: string;                   // 用户 ID
  iat: number;                   // 签发时间戳
  exp: number;                   // 过期时间戳
  iss?: string;                  // 签发者
  jti?: string;                  // JWT ID (唯一标识)
  userId: string;                // 用户ID
  username?: string;             // 用户名
  roles?: string[];              // 角色列表
  permissions?: string[];        // 权限列表
  tenantId?: string;             // 租户ID (多租户支持)
  organizationId?: string;       // 组织ID (多租户支持)
}

// Access Token 示例
{
  "sub": "user-uuid",
  "iat": 1708123456,
  "exp": 1708127056,
  "iss": "openchat",
  "jti": "550e8400-e29b-41d4-a716-446655440000",
  "userId": "user-uuid",
  "username": "john_doe",
  "roles": ["user", "admin"],
  "permissions": ["message:send", "message:read", "*"]
}

// Refresh Token 示例 (精简结构)
{
  "sub": "user-uuid",
  "iat": 1708123456,
  "exp": 1708728256,
  "iss": "openchat",
  "jti": "660e8400-e29b-41d4-a716-446655440001",
  "userId": "user-uuid",
  "username": "john_doe"
}
```

#### 5.2.2 Token 管理

```typescript
@Injectable()
export class TokenService {
  constructor(
    private jwtService: JwtService,
    private configService: ConfigService,
    private redisService: RedisService,
    private permissionService: PermissionService,
  ) {}

  async generateTokenPair(user: UserEntity): Promise<TokenPair> {
    const roles = await this.permissionService.getUserRoles(user.id);
    const permissions = await this.permissionService.getUserPermissions(user.id);
    
    const accessToken = this.jwtService.sign(
      {
        sub: user.id,
        userId: user.id,
        username: user.username,
        roles,
        permissions,
        jti: randomUUID(),
      },
      {
        expiresIn: '1h',
        issuer: 'openchat',
      }
    );

    const refreshToken = this.jwtService.sign(
      {
        sub: user.id,
        userId: user.id,
        username: user.username,
        jti: randomUUID(),
      },
      {
        expiresIn: '7d',
        issuer: 'openchat',
      }
    );

    return { accessToken, refreshToken, expiresIn: 3600 };
  }

  async revokeRefreshToken(userId: string, jti: string): Promise<void> {
    await this.redisService.del(`refresh:${userId}:${jti}`);
  }

  async revokeAllUserTokens(userId: string): Promise<void> {
    const keys = await this.redisService.keys(`refresh:${userId}:*`);
    if (keys.length > 0) {
      await this.redisService.del(...keys);
    }
  }
}
```

### 5.3 授权规范

#### 5.3.1 RBAC 权限模型

```typescript
// 角色定义
enum Role {
  USER = 'user',
  MODERATOR = 'moderator',
  ADMIN = 'admin',
  SUPER_ADMIN = 'super_admin',
}

// 权限定义
enum Permission {
  // 用户权限
  USER_READ = 'user:read',
  USER_WRITE = 'user:write',
  USER_DELETE = 'user:delete',

  // 消息权限
  MESSAGE_READ = 'message:read',
  MESSAGE_WRITE = 'message:write',
  MESSAGE_DELETE = 'message:delete',

  // 群组权限
  GROUP_CREATE = 'group:create',
  GROUP_MANAGE = 'group:manage',
  GROUP_DELETE = 'group:delete',
}

// 角色-权限映射
const RolePermissions: Record<Role, Permission[]> = {
  [Role.USER]: [
    Permission.USER_READ,
    Permission.USER_WRITE,
    Permission.MESSAGE_READ,
    Permission.MESSAGE_WRITE,
    Permission.GROUP_CREATE,
  ],
  [Role.MODERATOR]: [
    ...RolePermissions[Role.USER],
    Permission.MESSAGE_DELETE,
    Permission.GROUP_MANAGE,
  ],
  [Role.ADMIN]: [
    ...RolePermissions[Role.MODERATOR],
    Permission.USER_DELETE,
    Permission.GROUP_DELETE,
  ],
  [Role.SUPER_ADMIN]: Object.values(Permission),
};
```

#### 5.3.2 权限装饰器

```typescript
// 权限守卫
@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredPermissions = this.reflector.getAllAndOverride<Permission[]>(
      PERMISSIONS_KEY,
      [context.getHandler(), context.getClass()]
    );

    if (!requiredPermissions) return true;

    const { user } = context.switchToHttp().getRequest();
    const userPermissions = RolePermissions[user.role] || [];

    return requiredPermissions.every(permission =>
      userPermissions.includes(permission)
    );
  }
}

// 使用示例
@Controller('messages')
@UseGuards(JwtAuthGuard, PermissionsGuard)
export class MessageController {
  @Post()
  @RequirePermissions(Permission.MESSAGE_WRITE)
  async createMessage(@Body() data: CreateMessageDto) {
    // ...
  }

  @Delete(':id')
  @RequirePermissions(Permission.MESSAGE_DELETE)
  async deleteMessage(@Param('id') id: string) {
    // ...
  }
}
```

---

## 6. 安全规范

### 6.1 安全开发 checklist

#### 6.1.1 输入验证

- [ ] 所有用户输入必须经过验证（DTO + class-validator）
- [ ] 使用白名单验证，拒绝未知字段
- [ ] 字符串长度限制，防止缓冲区溢出
- [ ] 特殊字符转义，防止注入攻击
- [ ] 文件上传验证类型、大小、内容

#### 6.1.2 输出编码

- [ ] HTTP 响应设置正确的 Content-Type
- [ ] JSON 响应正确编码特殊字符
- [ ] 错误信息不泄露敏感信息
- [ ] 日志中敏感数据脱敏

#### 6.1.3 认证授权

- [ ] 敏感操作必须认证
- [ ] 权限检查在服务端完成
- [ ] 用户只能访问自己的数据（除非有权限）
- [ ] Token 有过期时间
- [ ] 密码使用强哈希算法（bcrypt/Argon2）

#### 6.1.4 会话管理

- [ ] 会话 ID 随机且足够长
- [ ] 会话有过期时间
- [ ] 登出时销毁会话
- [ ] 敏感操作重新认证

### 6.2 安全头配置

```typescript
// main.ts
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", process.env.API_URL],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: true,
  crossOriginOpenerPolicy: true,
  crossOriginResourcePolicy: { policy: "cross-origin" },
  dnsPrefetchControl: { allow: false },
  frameguard: { action: "deny" },
  hidePoweredBy: true,
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  },
  ieNoOpen: true,
  noSniff: true,
  originAgentCluster: true,
  permittedCrossDomainPolicies: { permittedPolicies: "none" },
  referrerPolicy: { policy: "strict-origin-when-cross-origin" },
  xssFilter: true,
}));
```

### 6.3 CORS 配置

```typescript
// main.ts
app.enableCors({
  origin: (origin, callback) => {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID'],
  credentials: true,
  maxAge: 86400,
});
```

### 6.4 限流配置

```typescript
// throttler.config.ts
export const throttlerConfig: ThrottlerModuleOptions = {
  throttlers: [
    // 默认限流: 100 请求/分钟
    {
      name: 'default',
      ttl: 60000,
      limit: 100,
    },
    // 严格限流: 5 请求/分钟（登录等敏感操作）
    {
      name: 'strict',
      ttl: 60000,
      limit: 5,
    },
    // 消息限流: 30 请求/分钟
    {
      name: 'message',
      ttl: 60000,
      limit: 30,
    },
  ],
};

// 使用装饰器
@Controller('auth')
export class AuthController {
  @Post('login')
  @Throttle(5, 60)  // 5 请求/分钟
  async login(@Body() data: LoginDto) {
    // ...
  }
}
```

### 6.5 敏感数据处理

```typescript
// 密码加密
import * as bcrypt from 'bcrypt';

const SALT_ROUNDS = 12;

async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS);
}

async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

// 数据脱敏
function maskEmail(email: string): string {
  const [local, domain] = email.split('@');
  const maskedLocal = local.slice(0, 2) + '***';
  return `${maskedLocal}@${domain}`;
}

function maskPhone(phone: string): string {
  return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
}

// 日志脱敏
function sanitizeLogData(data: any): any {
  const sensitiveFields = ['password', 'token', 'secret', 'credit_card'];
  const sanitized = { ...data };

  for (const field of sensitiveFields) {
    if (field in sanitized) {
      sanitized[field] = '***REDACTED***';
    }
  }

  return sanitized;
}
```

---

## 7. 性能规范

### 7.1 性能指标

| 指标 | 目标值 | 警告阈值 | 错误阈值 |
|------|--------|----------|----------|
| API 响应时间 (P99) | < 200ms | 500ms | 1000ms |
| 数据库查询时间 | < 50ms | 100ms | 500ms |
| 页面加载时间 | < 2s | 3s | 5s |
| 并发用户数 | 设计容量 | 80% 容量 | 100% 容量 |
| 错误率 | < 0.1% | 1% | 5% |
| CPU 使用率 | < 50% | 70% | 90% |
| 内存使用率 | < 70% | 85% | 95% |

### 7.2 缓存策略

```typescript
// 缓存分层
┌─────────────────────────────────────────────────────────────┐
│                      缓存架构                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  L1 缓存    │    │  L2 缓存    │    │  L3 缓存    │     │
│  │  (本地)     │    │  (Redis)    │    │  (数据库)   │     │
│  │             │    │             │    │             │     │
│  │  应用内存   │    │  分布式缓存 │    │  持久存储   │     │
│  │  1-5ms     │    │  5-20ms    │    │  20-100ms  │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
│         │                  │                  │             │
│         └──────────────────┼──────────────────┘             │
│                            ▼                               │
│                   ┌─────────────────┐                      │
│                   │   Cache-Aside   │                      │
│                   │   缓存模式      │                      │
│                   └─────────────────┘                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘

// 缓存装饰器
@Injectable()
export class UserService {
  @Cacheable({
    key: (userId: string) => `user:${userId}`,
    ttl: 300,  // 5分钟
  })
  async getUserById(userId: string): Promise<User> {
    return this.userRepository.findOne({ where: { id: userId } });
  }

  @CacheEvict({
    key: (user: User) => `user:${user.id}`,
  })
  async updateUser(user: User): Promise<User> {
    return this.userRepository.save(user);
  }
}
```

### 7.3 数据库优化

```typescript
// 连接池配置
TypeOrmModule.forRoot({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT, 10),
  username: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  // 连接池配置
  extra: {
    max: 20,                    // 最大连接数
    min: 5,                     // 最小连接数
    idleTimeoutMillis: 30000,   // 空闲超时
    connectionTimeoutMillis: 5000,  // 连接超时
    maxLifetime: 300000,        // 最大生命周期
  },
  // 查询日志（仅开发环境）
  logging: process.env.NODE_ENV === 'development',
  // 慢查询日志阈值
  logger: 'advanced-console',
});

// 查询优化示例
// ✅ 使用 select 只查询需要的字段
const users = await this.userRepository.find({
  select: ['id', 'name', 'avatar_url'],
  where: { status: 'active' },
});

// ✅ 使用 relations 避免 N+1
const usersWithOrders = await this.userRepository.find({
  relations: ['orders'],
  where: { id: In(userIds) },
});

// ✅ 批量操作
await this.userRepository.insert(users);  // 批量插入
await this.userRepository.update(ids, { status: 'inactive' });  // 批量更新
```

### 7.4 异步处理

```typescript
// 使用队列处理耗时操作
@Processor('email')
export class EmailProcessor {
  @Process('send')
  async handleSend(job: Job<SendEmailData>) {
    const { to, subject, body } = job.data;
    await this.emailService.send(to, subject, body);
  }
}

// 发布任务
@Injectable()
export class NotificationService {
  constructor(@InjectQueue('email') private emailQueue: Queue) {}

  async sendEmail(to: string, subject: string, body: string): Promise<void> {
    await this.emailQueue.add('send', { to, subject, body }, {
      delay: 0,
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 1000,
      },
    });
  }
}
```

---

## 8. 监控与日志规范

### 8.1 日志规范

```typescript
// 日志级别使用规范
┌─────────────────────────────────────────────────────────────┐
│  级别      │  使用场景                                      │
├─────────────────────────────────────────────────────────────┤
│  ERROR     │  系统错误，需要立即处理                        │
│  WARN      │  警告，可能需要关注                            │
│  INFO      │  正常业务流程记录                              │
│  DEBUG     │  调试信息，开发环境使用                        │
│  VERBOSE   │  详细日志，追踪问题使用                        │
└─────────────────────────────────────────────────────────────┘

// 日志格式
interface LogEntry {
  timestamp: string;      // ISO 8601 格式
  level: string;          // 日志级别
  message: string;        // 日志消息
  context: string;        // 上下文（类名/模块名）
  requestId: string;      // 请求追踪 ID
  userId?: string;        // 用户 ID（如果有）
  metadata: {             // 附加信息
    [key: string]: any;
  };
}

// 示例日志
{
  "timestamp": "2024-01-15T08:30:00.123Z",
  "level": "INFO",
  "message": "用户登录成功",
  "context": "AuthService",
  "requestId": "req_123456789",
  "userId": "user_abc123",
  "metadata": {
    "ip": "192.168.1.1",
    "userAgent": "Mozilla/5.0...",
    "loginMethod": "password"
  }
}
```

### 8.2 分布式追踪

```typescript
// 追踪上下文
@Injectable()
export class TracingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const traceId = request.headers['x-trace-id'] || randomUUID();
    const spanId = randomUUID();

    // 设置追踪上下文
    return next.handle().pipe(
      tap(() => {
        this.logger.debug('Request completed', {
          traceId,
          spanId,
          duration: Date.now() - request.startTime,
        });
      }),
    );
  }
}
```

### 8.3 健康检查

```typescript
// 健康检查端点
@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private db: TypeOrmHealthIndicator,
    private redis: RedisHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      () => this.db.pingCheck('database'),
      () => this.redis.pingCheck('redis'),
    ]);
  }

  @Get('liveness')
  liveness() {
    return { status: 'ok' };
  }

  @Get('readiness')
  async readiness() {
    // 检查所有依赖是否就绪
    const checks = await Promise.all([
      this.checkDatabase(),
      this.checkRedis(),
    ]);

    const allReady = checks.every(c => c.ready);
    return {
      status: allReady ? 'ready' : 'not_ready',
      checks,
    };
  }
}
```

### 8.4 指标监控

```typescript
// Prometheus 指标
@Injectable()
export class MetricsService {
  private readonly httpRequestsTotal: Counter;
  private readonly httpRequestDuration: Histogram;
  private readonly activeConnections: Gauge;

  constructor(private readonly prometheusService: PrometheusService) {
    this.httpRequestsTotal = this.prometheusService.getCounter({
      name: 'http_requests_total',
      help: 'Total HTTP requests',
      labelNames: ['method', 'route', 'status'],
    });

    this.httpRequestDuration = this.prometheusService.getHistogram({
      name: 'http_request_duration_seconds',
      help: 'HTTP request duration',
      labelNames: ['method', 'route'],
      buckets: [0.1, 0.5, 1, 2, 5],
    });

    this.activeConnections = this.prometheusService.getGauge({
      name: 'active_connections',
      help: 'Number of active connections',
    });
  }

  recordRequest(method: string, route: string, status: number, duration: number) {
    this.httpRequestsTotal.inc({ method, route, status: status.toString() });
    this.httpRequestDuration.observe({ method, route }, duration);
  }
}
```

---

## 9. 部署与运维规范

### 9.1 容器化规范

```dockerfile
# Dockerfile
# 阶段 1: 构建
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# 阶段 2: 运行
FROM node:20-alpine

# 安全: 使用非 root 用户
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

WORKDIR /app

# 只复制必要的文件
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package.json ./

USER nodejs

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health/liveness', (r) => r.statusCode === 200 ? process.exit(0) : process.exit(1))"

CMD ["node", "dist/main.js"]
```

### 9.2 Kubernetes 部署

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: openchat-api
  labels:
    app: openchat-api
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: openchat-api
  template:
    metadata:
      labels:
        app: openchat-api
    spec:
      containers:
        - name: api
          image: openchat/api:latest
          ports:
            - containerPort: 3000
          env:
            - name: NODE_ENV
              value: "production"
            - name: DB_HOST
              valueFrom:
                secretKeyRef:
                  name: db-secret
                  key: host
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /health/liveness
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health/readiness
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
```

### 9.3 CI/CD 流程

```yaml
# .github/workflows/ci.yml
name: CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Lint
        run: npm run lint

      - name: Type check
        run: npm run typecheck

      - name: Test
        run: npm run test:cov

      - name: Security audit
        run: npm audit --audit-level=high

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3

      - name: Build Docker image
        run: docker build -t openchat/api:${{ github.sha }} .

      - name: Push to registry
        run: |
          docker push openchat/api:${{ github.sha }}
          docker tag openchat/api:${{ github.sha }} openchat/api:latest
          docker push openchat/api:latest

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Deploy to Kubernetes
        run: |
          kubectl set image deployment/openchat-api api=openchat/api:${{ github.sha }}
          kubectl rollout status deployment/openchat-api
```

### 9.4 环境配置

```
# 环境配置规范
├── .env.development          # 开发环境
├── .env.staging              # 测试环境
├── .env.production           # 生产环境（加密存储）
└── .env.example              # 示例配置

# 配置优先级（从高到低）
1. 环境变量 (process.env)
2. .env.{NODE_ENV} 文件
3. .env 文件
4. 默认值
```

---

## 10. 代码质量规范

### 10.1 代码审查 checklist

#### 功能正确性
- [ ] 代码实现了需求描述的功能
- [ ] 边界条件被正确处理
- [ ] 错误情况被正确处理
- [ ] 没有明显的逻辑错误

#### 代码质量
- [ ] 代码遵循 SOLID 原则
- [ ] 函数/类职责单一
- [ ] 命名清晰且具有描述性
- [ ] 没有代码重复（DRY 原则）
- [ ] 复杂度在合理范围内

#### 安全性
- [ ] 输入验证完整
- [ ] 没有 SQL 注入风险
- [ ] 没有 XSS 风险
- [ ] 敏感数据被正确处理
- [ ] 权限检查完整

#### 性能
- [ ] 没有 N+1 查询问题
- [ ] 大数据量处理有分页
- [ ] 缓存使用合理
- [ ] 没有内存泄漏风险

#### 可测试性
- [ ] 代码易于单元测试
- [ ] 依赖可被 mock
- [ ] 有必要的测试覆盖

### 10.2 测试规范

```typescript
// 单元测试示例
describe('UserService', () => {
  let service: UserService;
  let repository: MockType<Repository<User>>;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        UserService,
        {
          provide: getRepositoryToken(User),
          useFactory: repositoryMockFactory,
        },
      ],
    }).compile();

    service = module.get(UserService);
    repository = module.get(getRepositoryToken(User));
  });

  describe('createUser', () => {
    it('should create a new user successfully', async () => {
      const dto = { name: 'Test', email: 'test@example.com', password: 'password123' };
      repository.save.mockReturnValue(Promise.resolve({ id: '1', ...dto }));

      const result = await service.createUser(dto);

      expect(result).toHaveProperty('id');
      expect(result.name).toBe(dto.name);
    });

    it('should throw error when email already exists', async () => {
      const dto = { name: 'Test', email: 'existing@example.com', password: 'password123' };
      repository.findOne.mockReturnValue(Promise.resolve({ id: '1', email: dto.email }));

      await expect(service.createUser(dto)).rejects.toThrow(ConflictException);
    });
  });
});

// 测试覆盖率要求
// - 语句覆盖率: >= 80%
// - 分支覆盖率: >= 70%
// - 函数覆盖率: >= 80%
// - 行覆盖率: >= 80%
```

### 10.3 文档规范

```typescript
/**
 * 用户服务
 *
 * 提供用户相关的业务逻辑，包括用户创建、查询、更新和删除。
 *
 * @example
 * ```typescript
 * const userService = new UserService(userRepository);
 * const user = await userService.createUser({
 *   name: '张三',
 *   email: 'zhangsan@example.com',
 *   password: 'password123'
 * });
 * ```
 */
@Injectable()
export class UserService {
  /**
   * 创建新用户
   *
   * @param data - 用户创建数据
   * @returns 创建成功的用户信息
   * @throws {ConflictException} 当邮箱已存在时抛出
   * @throws {ValidationException} 当数据验证失败时抛出
   *
   * @example
   * ```typescript
   * const user = await userService.createUser({
   *   name: '张三',
   *   email: 'zhangsan@example.com',
   *   password: 'SecurePass123!'
   * });
   * ```
   */
  async createUser(data: CreateUserDto): Promise<User> {
    // 实现...
  }
}
```

---

## 11. 附录

### 11.1 常用命令

```bash
# 开发
npm run dev              # 启动开发服务器
npm run build            # 构建生产版本
npm run test             # 运行测试
npm run test:watch       # 监视模式运行测试
npm run test:cov         # 生成测试覆盖率报告
npm run lint             # 运行 ESLint
npm run lint:fix         # 自动修复 ESLint 问题
npm run typecheck        # 运行 TypeScript 类型检查

# 数据库
npm run migration:generate  # 生成迁移文件
npm run migration:run       # 执行迁移
npm run migration:revert    # 回滚迁移
npm run db:seed             # 导入种子数据

# Docker
docker-compose up -d     # 启动依赖服务
docker-compose down      # 停止依赖服务
docker-compose logs -f   # 查看日志
```

### 11.2 推荐工具

| 类别 | 工具 | 用途 |
|------|------|------|
| 开发框架 | NestJS | 服务端框架 |
| ORM | TypeORM | 数据库操作 |
| 验证 | class-validator | DTO 验证 |
| 文档 | Swagger/OpenAPI | API 文档 |
| 测试 | Jest | 单元测试 |
| 缓存 | Redis | 分布式缓存 |
| 队列 | BullMQ | 消息队列 |
| 监控 | Prometheus + Grafana | 指标监控 |
| 日志 | Winston/Pino | 结构化日志 |
| 追踪 | Jaeger/Zipkin | 分布式追踪 |

### 11.3 参考资源

- [NestJS 官方文档](https://docs.nestjs.com/)
- [TypeORM 官方文档](https://typeorm.io/)
- [OWASP 安全指南](https://owasp.org/www-project-top-ten/)
- [12-Factor App](https://12factor.net/)
- [Google API 设计指南](https://cloud.google.com/apis/design)

---

**文档维护**

- 最后更新: 2024-01-15
- 维护者: 技术架构组
- 更新频率: 每季度审查

**变更日志**

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| v1.0.0 | 2024-01-15 | 初始版本 | 技术架构组 |

---

*本文档是 OpenChat 技术团队的权威参考，所有开发人员必须遵循。如有疑问，请咨询技术架构组。*
